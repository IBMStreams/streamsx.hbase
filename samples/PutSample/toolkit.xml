<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<toolkitModel xmlns="http://www.ibm.com/xmlns/prod/streams/spl/toolkit" productVersion="4.3.1.0" xmlns:common="http://www.ibm.com/xmlns/prod/streams/spl/common" xmlns:ti="http://www.ibm.com/xmlns/prod/streams/spl/toolkitInfo" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <toolkit name="PutSample" requiredProductVersion="4.0.0.0" version="1.0.1">
    <description>
The sample **PutSample** demonstrates three ways to put tuples into HBASE.


It demonstrates the use of HBASEPut for both ordinary put and checkAndPut.

In HBASE, the column is divided up into two parts, the **columnFamily**
and the **columnQualifier**.  

All columns in a columnFamily are grouped together on disk, so that which affects the efficience of access.  

The table has a fixed set of column families, and you may not add a tuple to any other family.  ColumnQualifiers, on the other hand, may be added at runtime.  

We show three ways to put data in a HBASE table. 

First, we read them from a file containing the **row**, **columnFamily**, **columnQualifer**,  and **value**.

	stream &lt;rstring character, rstring colF, rstring colQ, rstring value&gt; full = FileSource()
	{
		param
			file : "allAttributes.csv" ;
			format : csv ;
	}

	() as allSink = HBASEPut(full)
	{
		param
			tableName : "streamsSample_lotr" ;
			rowAttrName : "character" ;
			columnFamilyAttrName : "colF" ;
			columnQualifierAttrName : "colQ" ;
			valueAttrName : "value" ;
	}



Next, we read records from a file where the **columnFamily** is the same for all
rows, so the file only contains the **row**, **columnQualifier**, and **value**.

Here we enter a bunch of attributes about the appearance of characters.

We know these are all appearance-related, so we can use a static column family.

	stream&lt;rstring character, rstring feature, rstring description&gt; description = FileSource()
	{
		param
			file : "appearance.csv" ;
			format : csv ;
	}

	() as appearancePut = HBASEPut(description)
	{
		param
			tableName : "streamsSample_lotr" ;
			rowAttrName : "character" ;
			// Use the same column family for all tuples
			staticColumnFamily : "appearance" ;
			columnQualifierAttrName : "feature" ;
			valueAttrName : "description" ;
	}



Finally, we read from a file where the columnFamily and columnQualifier
are both assumed, and the file only contains a row and a value.

Use both a static column family and column qualifier.  

Here when we read the file, we know it contains just the start location for each character.  

	stream&lt;rstring character, rstring location&gt; startLocation = FileSource()
	{
		param
			file : "begin_location.csv" ;
			format : csv ;
	}

	() as startLocationPut = HBASEPut(startLocation)
	{
		param
			tableName : "streamsSample_lotr" ;
			rowAttrName : "character" ;
			// same column family and same column qualifier for all tuples
			staticColumnFamily : "location" ;
			staticColumnQualifier : "beginFellowship" ;
			valueAttrName : "location" ;
	}


To run this example, initialize a table with name streamsSample_lotr (short for
Lord of the Rings), and column families appearance and location.
In hbase shell, this is 

      hbase(main):023:0&gt; create 'streamsSample_lotr','appearance','location'`

After running every sample, you can scan the table to check the results.


      hbase(main):024:0&gt; scan 'streamsSample_lotr'
 
 
</description>
    <uriTable>
      <uri index="1" value="com.ibm.streamsx.hbase.sample/PutSample.spl"/>
      <uri index="3" value="com.ibm.streamsx.hbase.sample/BasicUpdate.spl"/>
      <uri index="4" value="com.ibm.streamsx.hbase.sample/CheckAndPut.spl"/>
      <uri index="2" value="com.ibm.streamsx.hbase.sample/PutExistCheck.spl"/>
    </uriTable>
    <namespace name="com.ibm.streamsx.hbase.sample">
      <compositeOp column="11" line="56" name="PutSample" potentialMain="true" uriIndex="1">
        <description>Show three ways to put tuples into HBASE.  </description>
      </compositeOp>
      <compositeOp column="11" line="27" name="PutExistCheck" potentialMain="true" uriIndex="2">
        <description>Use putAndCheck to put an entry only if another entry doesn't exist</description>
      </compositeOp>
      <compositeOp column="11" line="30" name="BasicUpdate" potentialMain="true" uriIndex="3">
        <description>Demostrate basic updating</description>
      </compositeOp>
      <compositeOp column="11" line="19" name="CheckAndPut" potentialMain="true" uriIndex="4">
        <description>Demonstrates check and put with the check including the value field</description>
      </compositeOp>
      <type column="6" line="7" name="ExistCheckType" static="true" type="rstring columnFamily, rstring columnQualifier" uriIndex="2"/>
      <type column="6" line="9" name="CheckType" static="true" type="rstring columnFamily, rstring columnQualifier, rstring value" uriIndex="4"/>
    </namespace>
    <dependency>
      <common:name>com.ibm.streamsx.hbase</common:name>
      <common:version>2.0.0</common:version>
    </dependency>
    <sabFiles>
      <ti:include path="toolkit.xml" root="toolkitDir"/>
      <ti:include path="impl/java/lib/**" root="toolkitDir"/>
      <ti:include path="impl/java/bin/**" root="toolkitDir"/>
      <ti:include path="impl/bin/**" root="toolkitDir"/>
      <ti:include path="impl/lib/**" root="toolkitDir"/>
      <ti:include path="impl/nl/*.dat" root="toolkitDir"/>
      <ti:include path="etc/**" root="toolkitDir"/>
      <ti:include path="lib/**" root="toolkitDir"/>
      <ti:include path="nl/**" root="toolkitDir"/>
      <ti:include path="opt/**" root="toolkitDir"/>
    </sabFiles>
  </toolkit>

</toolkitModel>
