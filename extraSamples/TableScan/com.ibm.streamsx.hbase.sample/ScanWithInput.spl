namespace com.ibm.streamsx.hbase.sample ;

/**
 * Test table scanning from input tuple.
 * 
 * The input tuple may have:
 * * startRow
 * * endRow
 * * both startRow and endRow
 * * rowPrefix
 * 
 * This composite tests all those four cases, using different ways of having the scan 
 * report output.
 */
composite ScanWithInput {
	param
		expression<list<rstring>> $prefixes : [ "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" ] ;
		expression<rstring> $tableName : "streamsSample_wordCount" ;
	graph
		stream<rstring startRow> justStart = Beacon(){
			param
				iterations : 1 ;
			output
				justStart : startRow = "Z" ;
		}

		()as justStartSink = ScanAndWrite(justStart){
			param
				tableName : $tableName ;
				file : "startRow.out" ;
				hbaseOutType : tuple<rstring row, rstring columnQualifier, int64 value> ;
		}

		stream<rstring endRow> justEnd = Beacon(){
			param
				iterations : 1 ;
			output
				justEnd : endRow = "D" ;
		}

		()as justEndSink = ScanAndWrite(justEnd){
			param
				tableName : $tableName ;
				file : "endRow.out" ;
				hbaseOutType : tuple<rstring row, rstring columnQualifier, list<tuple<int64 count, int64 time>> value> ;
		}

		stream<rstring startRow, rstring endRow> startEnd = Beacon(){
			param
				iterations : 1 ;
			output
				startEnd : startRow = "D", endRow = "Z" ;
		}

		()as startEndSink = ScanAndWrite(startEnd){
			param
				tableName : $tableName ;
				hbaseOutType : tuple<rstring row, rstring columnFamily, rstring columnQualifier, int64 value> ;
				file : "startEnd.out" ;
		}

		stream<rstring rowPrefix, uint64 iteration> prefix = Beacon(){
			param
				iterations : size($prefixes);
			output
				prefix : iteration = IterationCount(), rowPrefix = $prefixes [ IterationCount()] ;
		}

		()as PrefixSink = ScanAndWrite(prefix){
			param
				tableName : $tableName ;
				hbaseOutType : tuple<rstring row, tuple<int64 Book1> value> ;
				file : "prefix.out" ;
		}

}
